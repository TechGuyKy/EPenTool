using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using System.Management;
using System.IO;
using System.Diagnostics;
using Microsoft.Win32;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using EPenT.Core;
using EPenT.Models.Results;


namespace EPenT.Modules.Exploitation
{
    public class KernelExploits
    {
        private readonly IConfiguration _configuration;
        private readonly ILogger<KernelExploits> _logger;
        private readonly SecurityContext _securityContext;

        public KernelExploits(IConfiguration configuration, ILogger<KernelExploits> logger, SecurityContext securityContext)
        {
            _configuration = configuration ?? throw new ArgumentNullException(nameof(configuration));
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
            _securityContext = securityContext ?? throw new ArgumentNullException(nameof(securityContext));
        }

        public async Task<List<KernelExploitResult>> ExecuteAsync()
        {
            var results = new List<KernelExploitResult>();

            try
            {
                _logger.LogInformation("Starting kernel exploitation assessment");

                if (!_securityContext.IsElevated)
                {
                    _logger.LogWarning("Limited kernel assessment due to insufficient privileges");
                }

                results.AddRange(await CheckSystemVulnerabilities());
                results.AddRange(await CheckDriverVulnerabilities());
                results.AddRange(await CheckKnownKernelExploits());
                results.AddRange(await CheckSystemIntegrityFeatures());
                results.AddRange(await CheckKernelMitigations());

                _logger.LogInformation($"Kernel exploitation assessment completed. Found {results.Count} potential vulnerabilities");
                return results;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Kernel exploitation execution failed");
                results.Add(new KernelExploitResult
                {
                    ExploitName = "Kernel Exploitation Error",
                    Success = false,
                    Severity = "Error",
                    Description = "Kernel exploitation assessment failed",
                    Evidence = ex.Message
                });
                return results;
            }
        }

        private async Task<List<KernelExploitResult>> CheckSystemVulnerabilities()
        {
            var results = new List<KernelExploitResult>();

            try
            {
                await Task.Run(() =>
                {
                    var osVersion = Environment.OSVersion.Version;
                    var osVersionString = Environment.OSVersion.ToString();

                    var vulnerableVersions = new Dictionary<string, List<string>>
                    {
                        ["Windows 10"] = new List<string>
                        {
                            "10.0.10240", "10.0.10586", "10.0.14393", "10.0.15063",
                            "10.0.16299", "10.0.17134", "10.0.17763", "10.0.18362", "10.0.18363"
                        },
                        ["Windows 11"] = new List<string>
                        {
                            "10.0.22000"
                        },
                        ["Windows Server 2016"] = new List<string>
                        {
                            "10.0.14393"
                        },
                        ["Windows Server 2019"] = new List<string>
                        {
                            "10.0.17763"
                        }
                    };

                    foreach (var os in vulnerableVersions)
                    {
                        if (osVersionString.Contains(os.Key, StringComparison.OrdinalIgnoreCase))
                        {
                            foreach (var vulnVersion in os.Value)
                            {
                                if (osVersion.ToString().StartsWith(vulnVersion))
                                {
                                    results.Add(new KernelExploitResult
                                    {
                                        ExploitName = "Vulnerable OS Version",
                                        Success = true,
                                        Severity = "High",
                                        Description = $"System running potentially vulnerable OS version: {os.Key}",
                                        Evidence = $"OS Version: {osVersionString}, Build: {vulnVersion}",
                                        OSVersion = osVersionString,
                                        KernelVersion = osVersion.ToString()
                                    });
                                }
                            }
                        }
                    }

                    CheckSpecificCVEs(osVersion, osVersionString, results);
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to check system vulnerabilities");
            }

            return results;
        }

        private async Task<List<KernelExploitResult>> CheckDriverVulnerabilities()
        {
            var results = new List<KernelExploitResult>();

            try
            {
                await Task.Run(() =>
                {
                    using var searcher = new ManagementObjectSearcher("SELECT * FROM Win32_SystemDriver");
                    using var driverResults = searcher.Get();

                    var vulnerableDrivers = new[]
                    {
                        "capcom", "gdrv", "dbutil", "mimidrv", "procexp",
                        "winring0", "winio", "phymem", "physmem"
                    };

                    foreach (ManagementObject driver in driverResults)
                    {
                        try
                        {
                            var driverName = driver["Name"]?.ToString()?.ToLower();
                            var pathName = driver["PathName"]?.ToString();
                            var state = driver["State"]?.ToString();

                            if (!string.IsNullOrEmpty(driverName))
                            {
                                foreach (var vulnDriver in vulnerableDrivers)
                                {
                                    if (driverName.Contains(vulnDriver))
                                    {
                                        results.Add(new KernelExploitResult
                                        {
                                            ExploitName = "Vulnerable Driver",
                                            Success = true,
                                            Severity = "Critical",
                                            Description = $"Potentially vulnerable driver loaded: {driverName}",
                                            Evidence = $"Driver: {driverName}, Path: {pathName}, State: {state}",
                                            TargetDriver = driverName,
                                            DriverPath = pathName
                                        });
                                    }
                                }

                                CheckUnsignedDrivers(driver, results);
                            }
                        }
                        catch (Exception ex)
                        {
                            _logger.LogDebug(ex, "Failed to analyze driver");
                        }
                        finally
                        {
                            driver?.Dispose();
                        }
                    }
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to check driver vulnerabilities");
            }

            return results;
        }

        private async Task<List<KernelExploitResult>> CheckKnownKernelExploits()
        {
            var results = new List<KernelExploitResult>();

            try
            {
                await Task.Run(() =>
                {
                    var osVersion = Environment.OSVersion.Version;
                    var exploits = GetKnownExploitsByVersion(osVersion);

                    foreach (var exploit in exploits)
                    {
                        results.Add(new KernelExploitResult
                        {
                            ExploitName = exploit.Name,
                            Success = true,
                            Severity = exploit.Severity,
                            Description = exploit.Description,
                            Evidence = $"System version {osVersion} is vulnerable to {exploit.CVE}",
                            CVE = exploit.CVE,
                            OSVersion = osVersion.ToString(),
                            KernelVersion = osVersion.ToString()
                        });
                    }
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to check known kernel exploits");
            }

            return results;
        }

        private async Task<List<KernelExploitResult>> CheckSystemIntegrityFeatures()
        {
            var results = new List<KernelExploitResult>();

            try
            {
                await Task.Run(() =>
                {
                    CheckKernelGuardStatus(results);
                    CheckHVCIStatus(results);
                    CheckCFGStatus(results);
                    CheckSMEPStatus(results);
                    CheckKASLRStatus(results);
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to check system integrity features");
            }

            return results;
        }

        private async Task<List<KernelExploitResult>> CheckKernelMitigations()
        {
            var results = new List<KernelExploitResult>();

            try
            {
                await Task.Run(() =>
                {
                    CheckDEPStatus(results);
                    CheckASLRStatus(results);
                    CheckSEHOPStatus(results);
                    CheckStackCookiesStatus(results);
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to check kernel mitigations");
            }

            return results;
        }

        private void CheckSpecificCVEs(Version osVersion, string osVersionString, List<KernelExploitResult> results)
        {
            var cveChecks = new Dictionary<string, Func<Version, string, bool>>
            {
                ["CVE-2020-1472"] = (version, versionString) =>
                    versionString.Contains("Windows Server", StringComparison.OrdinalIgnoreCase),
                ["CVE-2021-1675"] = (version, versionString) =>
                    version.Major == 10 && version.Build < 19043,
                ["CVE-2021-34527"] = (version, versionString) =>
                    version.Major == 10 && version.Build < 19043,
                ["CVE-2022-21882"] = (version, versionString) =>
                    version.Major == 10 && version.Build < 19044,
                ["CVE-2022-30190"] = (version, versionString) =>
                    version.Major == 10 && version.Build < 19044
            };

            foreach (var cve in cveChecks)
            {
                try
                {
                    if (cve.Value(osVersion, osVersionString))
                    {
                        results.Add(new KernelExploitResult
                        {
                            ExploitName = $"Known CVE: {cve.Key}",
                            Success = true,
                            Severity = "High",
                            Description = $"System may be vulnerable to {cve.Key}",
                            Evidence = $"OS Version: {osVersionString}",
                            CVE = cve.Key,
                            OSVersion = osVersionString
                        });
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogDebug(ex, $"Failed to check CVE: {cve.Key}");
                }
            }
        }

        private void CheckUnsignedDrivers(ManagementObject driver, List<KernelExploitResult> results)
        {
            try
            {
                var driverName = driver["Name"]?.ToString();
                var pathName = driver["PathName"]?.ToString();

                if (!string.IsNullOrEmpty(pathName) && File.Exists(pathName))
                {
                    var versionInfo = FileVersionInfo.GetVersionInfo(pathName);
                    if (string.IsNullOrEmpty(versionInfo.CompanyName) ||
                        !versionInfo.CompanyName.Contains("Microsoft", StringComparison.OrdinalIgnoreCase))
                    {
                        results.Add(new KernelExploitResult
                        {
                            ExploitName = "Third-party Driver",
                            Success = true,
                            Severity = "Medium",
                            Description = $"Third-party driver loaded: {driverName}",
                            Evidence = $"Driver: {driverName}, Company: {versionInfo.CompanyName}",
                            TargetDriver = driverName,
                            DriverPath = pathName
                        });
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogDebug(ex, "Failed to check driver signature");
            }
        }

        private List<KnownExploit> GetKnownExploitsByVersion(Version osVersion)
        {
            var exploits = new List<KnownExploit>();

            if (osVersion.Major == 10)
            {
                if (osVersion.Build < 19041)
                {
                    exploits.Add(new KnownExploit
                    {
                        Name = "CVE-2020-0796 SMBGhost",
                        CVE = "CVE-2020-0796",
                        Severity = "Critical",
                        Description = "SMBv3 compression buffer overflow vulnerability"
                    });
                }

                if (osVersion.Build < 18363)
                {
                    exploits.Add(new KnownExploit
                    {
                        Name = "CVE-2019-1388 UAC Bypass",
                        CVE = "CVE-2019-1388",
                        Severity = "High",
                        Description = "Windows Certificate Dialog privilege escalation"
                    });
                }

                if (osVersion.Build < 17134)
                {
                    exploits.Add(new KnownExploit
                    {
                        Name = "CVE-2018-8120 Win32k",
                        CVE = "CVE-2018-8120",
                        Severity = "High",
                        Description = "Win32k privilege escalation vulnerability"
                    });
                }
            }

            if (osVersion.Major == 6)
            {
                exploits.Add(new KnownExploit
                {
                    Name = "MS16-032 Secondary Logon",
                    CVE = "CVE-2016-0099",
                    Severity = "High",
                    Description = "Secondary Logon service privilege escalation"
                });

                exploits.Add(new KnownExploit
                {
                    Name = "MS15-051 Client/Server Runtime",
                    CVE = "CVE-2015-1701",
                    Severity = "High",
                    Description = "Windows Kernel privilege escalation"
                });
            }

            return exploits;
        }

        private void CheckKernelGuardStatus(List<KernelExploitResult> results)
        {
            try
            {
                using var key = Registry.LocalMachine.OpenSubKey(@"SYSTEM\CurrentControlSet\Control\DeviceGuard");
                if (key != null)
                {
                    var enableVirtualizationBasedSecurity = key.GetValue("EnableVirtualizationBasedSecurity");
                    var requirePlatformSecurityFeatures = key.GetValue("RequirePlatformSecurityFeatures");

                    if (enableVirtualizationBasedSecurity?.ToString() != "1")
                    {
                        results.Add(new KernelExploitResult
                        {
                            ExploitName = "Device Guard Disabled",
                            Success = true,
                            Severity = "Medium",
                            Description = "Device Guard virtualization-based security is disabled",
                            Evidence = $"EnableVirtualizationBasedSecurity = {enableVirtualizationBasedSecurity}",
                            MitigationBypass = "Device Guard"
                        });
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogDebug(ex, "Failed to check Kernel Guard status");
            }
        }

        private void CheckHVCIStatus(List<KernelExploitResult> results)
        {
            try
            {
                using var key = Registry.LocalMachine.OpenSubKey(@"SYSTEM\CurrentControlSet\Control\DeviceGuard\Scenarios\HypervisorEnforcedCodeIntegrity");
                if (key != null)
                {
                    var enabled = key.GetValue("Enabled");
                    if (enabled?.ToString() != "1")
                    {
                        results.Add(new KernelExploitResult
                        {
                            ExploitName = "HVCI Disabled",
                            Success = true,
                            Severity = "Medium",
                            Description = "Hypervisor-protected Code Integrity is disabled",
                            Evidence = $"HVCI Enabled = {enabled}",
                            MitigationBypass = "HVCI"
                        });
                    }
                }
                else
                {
                    results.Add(new KernelExploitResult
                    {
                        ExploitName = "HVCI Not Configured",
                        Success = true,
                        Severity = "Low",
                        Description = "HVCI registry key not found - feature may not be configured",
                        Evidence = "HVCI registry key missing",
                        MitigationBypass = "HVCI"
                    });
                }
            }
            catch (Exception ex)
            {
                _logger.LogDebug(ex, "Failed to check HVCI status");
            }
        }

        private void CheckCFGStatus(List<KernelExploitResult> results)
        {
            try
            {
                using var key = Registry.LocalMachine.OpenSubKey(@"SYSTEM\CurrentControlSet\Control\Session Manager\kernel");
                if (key != null)
                {
                    var cfgBitmap = key.GetValue("CFGBitMap");
                    if (cfgBitmap == null)
                    {
                        results.Add(new KernelExploitResult
                        {
                            ExploitName = "CFG Status Unknown",
                            Success = true,
                            Severity = "Low",
                            Description = "Control Flow Guard status cannot be determined",
                            Evidence = "CFGBitMap registry value not found",
                            MitigationBypass = "CFG"
                        });
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogDebug(ex, "Failed to check CFG status");
            }
        }

        private void CheckSMEPStatus(List<KernelExploitResult> results)
        {
            try
            {
                var osVersion = Environment.OSVersion.Version;
                if (osVersion.Major >= 6 && osVersion.Minor >= 2)
                {
                    results.Add(new KernelExploitResult
                    {
                        ExploitName = "SMEP Status Check",
                        Success = true,
                        Severity = "Info",
                        Description = "System supports SMEP (Supervisor Mode Execution Prevention)",
                        Evidence = $"OS Version: {osVersion} supports SMEP",
                        MitigationBypass = "SMEP"
                    });
                }
                else
                {
                    results.Add(new KernelExploitResult
                    {
                        ExploitName = "SMEP Not Available",
                        Success = true,
                        Severity = "Medium",
                        Description = "SMEP not available on this OS version",
                        Evidence = $"OS Version: {osVersion} does not support SMEP",
                        MitigationBypass = "SMEP"
                    });
                }
            }
            catch (Exception ex)
            {
                _logger.LogDebug(ex, "Failed to check SMEP status");
            }
        }

        private void CheckKASLRStatus(List<KernelExploitResult> results)
        {
            try
            {
                var osVersion = Environment.OSVersion.Version;
                if (osVersion.Major >= 6)
                {
                    results.Add(new KernelExploitResult
                    {
                        ExploitName = "KASLR Status Check",
                        Success = true,
                        Severity = "Info",
                        Description = "System supports KASLR (Kernel Address Space Layout Randomization)",
                        Evidence = $"OS Version: {osVersion} supports KASLR",
                        MitigationBypass = "KASLR"
                    });
                }
            }
            catch (Exception ex)
            {
                _logger.LogDebug(ex, "Failed to check KASLR status");
            }
        }

        private void CheckDEPStatus(List<KernelExploitResult> results)
        {
            try
            {
                using var key = Registry.LocalMachine.OpenSubKey(@"SYSTEM\CurrentControlSet\Control\Session Manager\Memory Management");
                if (key != null)
                {
                    var executeOptions = key.GetValue("ExecuteOptions");
                    if (executeOptions != null)
                    {
                        var depValue = Convert.ToInt32(executeOptions);
                        if ((depValue & 1) == 0)
                        {
                            results.Add(new KernelExploitResult
                            {
                                ExploitName = "DEP Disabled",
                                Success = true,
                                Severity = "High",
                                Description = "Data Execution Prevention is disabled",
                                Evidence = $"ExecuteOptions = {depValue}",
                                MitigationBypass = "DEP"
                            });
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogDebug(ex, "Failed to check DEP status");
            }
        }

        private void CheckASLRStatus(List<KernelExploitResult> results)
        {
            try
            {
                using var key = Registry.LocalMachine.OpenSubKey(@"SYSTEM\CurrentControlSet\Control\Session Manager\Memory Management");
                if (key != null)
                {
                    var moveImages = key.GetValue("MoveImages");
                    if (moveImages?.ToString() != "1")
                    {
                        results.Add(new KernelExploitResult
                        {
                            ExploitName = "ASLR Weakened",
                            Success = true,
                            Severity = "Medium",
                            Description = "Address Space Layout Randomization may be weakened",
                            Evidence = $"MoveImages = {moveImages}",
                            MitigationBypass = "ASLR"
                        });
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogDebug(ex, "Failed to check ASLR status");
            }
        }

        private void CheckSEHOPStatus(List<KernelExploitResult> results)
        {
            try
            {
                using var key = Registry.LocalMachine.OpenSubKey(@"SYSTEM\CurrentControlSet\Control\Session Manager\kernel");
                if (key != null)
                {
                    var disableExceptionChainValidation = key.GetValue("DisableExceptionChainValidation");
                    if (disableExceptionChainValidation?.ToString() == "1")
                    {
                        results.Add(new KernelExploitResult
                        {
                            ExploitName = "SEHOP Disabled",
                            Success = true,
                            Severity = "Medium",
                            Description = "Structured Exception Handler Overwrite Protection is disabled",
                            Evidence = $"DisableExceptionChainValidation = {disableExceptionChainValidation}",
                            MitigationBypass = "SEHOP"
                        });
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogDebug(ex, "Failed to check SEHOP status");
            }
        }

        private void CheckStackCookiesStatus(List<KernelExploitResult> results)
        {
            try
            {
                var osVersion = Environment.OSVersion.Version;
                if (osVersion.Major >= 6)
                {
                    results.Add(new KernelExploitResult
                    {
                        ExploitName = "Stack Cookies Available",
                        Success = true,
                        Severity = "Info",
                        Description = "System supports stack cookies (buffer overflow protection)",
                        Evidence = $"OS Version: {osVersion} supports stack cookies",
                        MitigationBypass = "Stack Cookies"
                    });
                }
            }
            catch (Exception ex)
            {
                _logger.LogDebug(ex, "Failed to check stack cookies status");
            }
        }

        private class KnownExploit
        {
            public string Name { get; set; } = string.Empty;
            public string CVE { get; set; } = string.Empty;
            public string Severity { get; set; } = string.Empty;
            public string Description { get; set; } = string.Empty;
        }
    }
}