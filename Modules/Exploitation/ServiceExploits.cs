using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using System.ServiceProcess;
using System.Management;
using System.IO;
using System.Diagnostics;
using Microsoft.Win32;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using EPenT.Core;
using EPenT.Models.Results;

namespace EPenT.Modules.Exploitation
{
    public class ServiceExploits
    {
        private readonly IConfiguration _configuration;
        private readonly ILogger<ServiceExploits> _logger;
        private readonly SecurityContext _securityContext;

        public ServiceExploits(IConfiguration configuration, ILogger<ServiceExploits> logger, SecurityContext securityContext)
        {
            _configuration = configuration ?? throw new ArgumentNullException(nameof(configuration));
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
            _securityContext = securityContext ?? throw new ArgumentNullException(nameof(securityContext));
        }

        public async Task<List<ServiceExploitResult>> ExecuteAsync()
        {
            var results = new List<ServiceExploitResult>();

            try
            {
                _logger.LogInformation("Starting service exploitation assessment");

                results.AddRange(await ExploitUnquotedServicePaths());
                results.AddRange(await ExploitWeakServicePermissions());
                results.AddRange(await ExploitServiceBinaryPermissions());
                results.AddRange(await ExploitServiceRegistryPermissions());
                results.AddRange(await ExploitServiceDLLHijacking());
                results.AddRange(await CheckInsecureServiceConfigurations());

                _logger.LogInformation($"Service exploitation assessment completed. Found {results.Count} potential exploits");
                return results;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Service exploitation execution failed");
                results.Add(new ServiceExploitResult
                {
                    ServiceName = "Service Exploitation Error",
                    Success = false,
                    Severity = "Error",
                    Description = "Service exploitation assessment failed",
                    Evidence = ex.Message
                });
                return results;
            }
        }

        private async Task<List<ServiceExploitResult>> ExploitUnquotedServicePaths()
        {
            var results = new List<ServiceExploitResult>();

            try
            {
                await Task.Run(() =>
                {
                    using var searcher = new ManagementObjectSearcher("SELECT Name, PathName, StartMode, State FROM Win32_Service");
                    using var serviceResults = searcher.Get();

                    foreach (ManagementObject service in serviceResults)
                    {
                        try
                        {
                            var serviceName = service["Name"]?.ToString();
                            var pathName = service["PathName"]?.ToString();
                            var startMode = service["StartMode"]?.ToString();
                            var state = service["State"]?.ToString();

                            if (!string.IsNullOrEmpty(pathName) && IsUnquotedServicePath(pathName))
                            {
                                var exploitPaths = GetUnquotedPathExploitTargets(pathName);

                                foreach (var exploitPath in exploitPaths)
                                {
                                    if (CanWriteToPath(Path.GetDirectoryName(exploitPath)))
                                    {
                                        results.Add(new ServiceExploitResult
                                        {
                                            ServiceName = serviceName ?? "Unknown",
                                            ExploitType = "Unquoted Service Path",
                                            Success = true,
                                            Severity = "High",
                                            Description = $"Unquoted service path exploit possible for '{serviceName}'",
                                            Evidence = $"Service: {serviceName}, Path: {pathName}, Exploit Target: {exploitPath}",
                                            ServicePath = pathName,
                                            ExploitPath = exploitPath,
                                            ServiceStartMode = startMode,
                                            ServiceState = state
                                        });
                                    }
                                }
                            }
                        }
                        catch (Exception ex)
                        {
                            _logger.LogDebug(ex, "Failed to analyze service for unquoted path exploit");
                        }
                        finally
                        {
                            service?.Dispose();
                        }
                    }
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to exploit unquoted service paths");
            }

            return results;
        }

        private async Task<List<ServiceExploitResult>> ExploitWeakServicePermissions()
        {
            var results = new List<ServiceExploitResult>();

            try
            {
                await Task.Run(() =>
                {
                    var services = ServiceController.GetServices();

                    foreach (var service in services)
                    {
                        try
                        {
                            if (HasWeakServicePermissions(service.ServiceName))
                            {
                                results.Add(new ServiceExploitResult
                                {
                                    ServiceName = service.ServiceName,
                                    ExploitType = "Weak Service Permissions",
                                    Success = true,
                                    Severity = "High",
                                    Description = $"Service '{service.ServiceName}' has weak permissions allowing modification",
                                    Evidence = $"Service: {service.ServiceName}, Status: {service.Status}",
                                    ServiceState = service.Status.ToString()
                                });
                            }
                        }
                        catch (Exception ex)
                        {
                            _logger.LogDebug(ex, $"Failed to check permissions for service: {service.ServiceName}");
                        }
                        finally
                        {
                            service?.Dispose();
                        }
                    }
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to exploit weak service permissions");
            }

            return results;
        }

        private async Task<List<ServiceExploitResult>> ExploitServiceBinaryPermissions()
        {
            var results = new List<ServiceExploitResult>();

            try
            {
                await Task.Run(() =>
                {
                    using var searcher = new ManagementObjectSearcher("SELECT Name, PathName, StartName FROM Win32_Service");
                    using var serviceResults = searcher.Get();

                    foreach (ManagementObject service in serviceResults)
                    {
                        try
                        {
                            var serviceName = service["Name"]?.ToString();
                            var pathName = service["PathName"]?.ToString();
                            var startName = service["StartName"]?.ToString();

                            if (!string.IsNullOrEmpty(pathName))
                            {
                                var binaryPath = ExtractBinaryPath(pathName);
                                if (File.Exists(binaryPath) && CanWriteToFile(binaryPath))
                                {
                                    results.Add(new ServiceExploitResult
                                    {
                                        ServiceName = serviceName ?? "Unknown",
                                        ExploitType = "Weak Service Binary Permissions",
                                        Success = true,
                                        Severity = "Critical",
                                        Description = $"Service binary '{binaryPath}' is writable",
                                        Evidence = $"Service: {serviceName}, Binary: {binaryPath}, StartName: {startName}",
                                        ServicePath = binaryPath,
                                        ExploitPath = binaryPath
                                    });
                                }
                            }
                        }
                        catch (Exception ex)
                        {
                            _logger.LogDebug(ex, "Failed to check service binary permissions");
                        }
                        finally
                        {
                            service?.Dispose();
                        }
                    }
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to exploit service binary permissions");
            }

            return results;
        }

        private async Task<List<ServiceExploitResult>> ExploitServiceRegistryPermissions()
        {
            var results = new List<ServiceExploitResult>();

            try
            {
                await Task.Run(() =>
                {
                    using var servicesKey = Registry.LocalMachine.OpenSubKey(@"SYSTEM\CurrentControlSet\Services");
                    if (servicesKey != null)
                    {
                        foreach (var serviceName in servicesKey.GetSubKeyNames())
                        {
                            try
                            {
                                using var serviceKey = servicesKey.OpenSubKey(serviceName, true);
                                if (serviceKey != null)
                                {
                                    results.Add(new ServiceExploitResult
                                    {
                                        ServiceName = serviceName,
                                        ExploitType = "Weak Service Registry Permissions",
                                        Success = true,
                                        Severity = "High",
                                        Description = $"Service registry key for '{serviceName}' is writable",
                                        Evidence = $"Registry key: HKLM\\SYSTEM\\CurrentControlSet\\Services\\{serviceName}",
                                        ServicePath = $@"HKLM\SYSTEM\CurrentControlSet\Services\{serviceName}"
                                    });
                                }
                            }
                            catch (UnauthorizedAccessException)
                            {
                                // Expected for most services - not writable
                            }
                            catch (Exception ex)
                            {
                                _logger.LogDebug(ex, $"Failed to check registry permissions for service: {serviceName}");
                            }
                        }
                    }
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to exploit service registry permissions");
            }

            return results;
        }

        private async Task<List<ServiceExploitResult>> ExploitServiceDLLHijacking()
        {
            var results = new List<ServiceExploitResult>();

            try
            {
                await Task.Run(() =>
                {
                    var commonDLLs = new[]
                    {
                        "kernel32.dll", "advapi32.dll", "user32.dll", "ntdll.dll",
                        "msvcrt.dll", "shell32.dll", "ole32.dll", "ws2_32.dll"
                    };

                    using var searcher = new ManagementObjectSearcher("SELECT Name, PathName FROM Win32_Service");
                    using var serviceResults = searcher.Get();

                    foreach (ManagementObject service in serviceResults)
                    {
                        try
                        {
                            var serviceName = service["Name"]?.ToString();
                            var pathName = service["PathName"]?.ToString();

                            if (!string.IsNullOrEmpty(pathName))
                            {
                                var binaryPath = ExtractBinaryPath(pathName);
                                var binaryDir = Path.GetDirectoryName(binaryPath);

                                if (Directory.Exists(binaryDir) && CanWriteToPath(binaryDir))
                                {
                                    foreach (var dll in commonDLLs)
                                    {
                                        var dllPath = Path.Combine(binaryDir, dll);
                                        if (!File.Exists(dllPath))
                                        {
                                            results.Add(new ServiceExploitResult
                                            {
                                                ServiceName = serviceName ?? "Unknown",
                                                ExploitType = "Service DLL Hijacking",
                                                Success = true,
                                                Severity = "High",
                                                Description = $"DLL hijacking possible for service '{serviceName}' with '{dll}'",
                                                Evidence = $"Service: {serviceName}, Missing DLL: {dllPath}",
                                                ServicePath = binaryPath,
                                                ExploitPath = dllPath
                                            });
                                        }
                                    }
                                }
                            }
                        }
                        catch (Exception ex)
                        {
                            _logger.LogDebug(ex, "Failed to check DLL hijacking for service");
                        }
                        finally
                        {
                            service?.Dispose();
                        }
                    }
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to check service DLL hijacking");
            }

            return results;
        }

        private async Task<List<ServiceExploitResult>> CheckInsecureServiceConfigurations()
        {
            var results = new List<ServiceExploitResult>();

            try
            {
                await Task.Run(() =>
                {
                    using var searcher = new ManagementObjectSearcher("SELECT Name, StartName, StartMode FROM Win32_Service WHERE StartName LIKE '%LocalSystem%' OR StartName LIKE '%SYSTEM%'");
                    using var serviceResults = searcher.Get();

                    foreach (ManagementObject service in serviceResults)
                    {
                        try
                        {
                            var serviceName = service["Name"]?.ToString();
                            var startName = service["StartName"]?.ToString();
                            var startMode = service["StartMode"]?.ToString();

                            if (string.Equals(startMode, "Auto", StringComparison.OrdinalIgnoreCase))
                            {
                                results.Add(new ServiceExploitResult
                                {
                                    ServiceName = serviceName ?? "Unknown",
                                    ExploitType = "Privileged Service Configuration",
                                    Success = true,
                                    Severity = "Medium",
                                    Description = $"Service '{serviceName}' runs as SYSTEM with automatic start",
                                    Evidence = $"Service: {serviceName}, Account: {startName}, StartMode: {startMode}",
                                    ServiceStartMode = startMode
                                });
                            }
                        }
                        catch (Exception ex)
                        {
                            _logger.LogDebug(ex, "Failed to check service configuration");
                        }
                        finally
                        {
                            service?.Dispose();
                        }
                    }
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to check insecure service configurations");
            }

            return results;
        }

        private bool IsUnquotedServicePath(string pathName)
        {
            if (string.IsNullOrEmpty(pathName)) return false;

            var trimmedPath = pathName.Trim();
            if (trimmedPath.StartsWith("\"")) return false;

            return trimmedPath.Contains(" ") && !trimmedPath.StartsWith("C:\\Windows\\System32");
        }

        private List<string> GetUnquotedPathExploitTargets(string pathName)
        {
            var targets = new List<string>();

            if (string.IsNullOrEmpty(pathName)) return targets;

            var parts = pathName.Split(' ');
            var currentPath = string.Empty;

            for (int i = 0; i < parts.Length - 1; i++)
            {
                if (i == 0)
                {
                    currentPath = parts[i];
                }
                else
                {
                    currentPath += " " + parts[i];
                }

                if (!currentPath.EndsWith(".exe", StringComparison.OrdinalIgnoreCase))
                {
                    targets.Add(currentPath + ".exe");
                }
            }

            return targets;
        }

        private bool HasWeakServicePermissions(string serviceName)
        {
            try
            {
                var startInfo = new ProcessStartInfo
                {
                    FileName = "sc.exe",
                    Arguments = $"sdshow {serviceName}",
                    UseShellExecute = false,
                    RedirectStandardOutput = true,
                    CreateNoWindow = true
                };

                using var process = Process.Start(startInfo);
                if (process != null)
                {
                    var output = process.StandardOutput.ReadToEnd();
                    process.WaitForExit();

                    // Check for write permissions (WP), generic write (GW), or full control (FA)
                    return output.Contains("WP") || output.Contains("GW") || output.Contains("FA") ||
                           output.Contains("CC") || output.Contains("DC") || output.Contains("WD");
                }
            }
            catch (Exception ex)
            {
                _logger.LogDebug(ex, $"Failed to check service permissions for: {serviceName}");
            }

            return false;
        }

        private string ExtractBinaryPath(string pathName)
        {
            if (string.IsNullOrEmpty(pathName)) return string.Empty;

            var trimmedPath = pathName.Trim();

            if (trimmedPath.StartsWith("\""))
            {
                var endQuote = trimmedPath.IndexOf("\"", 1);
                if (endQuote > 0)
                {
                    return trimmedPath.Substring(1, endQuote - 1);
                }
            }

            var spaceIndex = trimmedPath.IndexOf(' ');
            if (spaceIndex > 0)
            {
                return trimmedPath.Substring(0, spaceIndex);
            }

            return trimmedPath;
        }

        private bool CanWriteToPath(string path)
        {
            try
            {
                if (string.IsNullOrEmpty(path) || !Directory.Exists(path)) return false;

                var testFile = Path.Combine(path, $"test_{Guid.NewGuid():N}.tmp");
                File.WriteAllText(testFile, "test");
                File.Delete(testFile);
                return true;
            }
            catch
            {
                return false;
            }
        }

        private bool CanWriteToFile(string filePath)
        {
            try
            {
                if (string.IsNullOrEmpty(filePath) || !File.Exists(filePath)) return false;

                using var stream = File.Open(filePath, FileMode.Open, FileAccess.Write);
                return stream.CanWrite;
            }
            catch
            {
                return false;
            }
        }
    }
}