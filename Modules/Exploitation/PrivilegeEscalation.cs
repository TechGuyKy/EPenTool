using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using System.IO;
using System.Diagnostics;
using System.Security.Principal;
using System.Management;
using Microsoft.Win32;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using EPenT.Core;
using EPenT.Models.Results;

namespace EPenT.Modules.Exploitation
{
    public class PrivilegeEscalation
    {
        private readonly IConfiguration _configuration;
        private readonly ILogger<PrivilegeEscalation> _logger;
        private readonly SecurityContext _securityContext;

        public PrivilegeEscalation(IConfiguration configuration, ILogger<PrivilegeEscalation> logger, SecurityContext securityContext)
        {
            _configuration = configuration ?? throw new ArgumentNullException(nameof(configuration));
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
            _securityContext = securityContext ?? throw new ArgumentNullException(nameof(securityContext));
        }

        public async Task<List<PrivilegeEscalationResult>> ExecuteAsync()
        {
            var results = new List<PrivilegeEscalationResult>();

            try
            {
                _logger.LogInformation("Starting privilege escalation assessment");

                if (_securityContext.IsElevated)
                {
                    _logger.LogInformation("Already running with elevated privileges");
                    results.Add(new PrivilegeEscalationResult
                    {
                        TechniqueName = "Current Privilege Level",
                        Success = true,
                        Severity = "Info",
                        Description = "Process is already running with elevated privileges",
                        Evidence = $"Current user: {_securityContext.Username}, Elevated: {_securityContext.IsElevated}"
                    });
                }

                results.AddRange(await CheckUnquotedServicePaths());
                results.AddRange(await CheckWeakServicePermissions());
                results.AddRange(await CheckAlwaysInstallElevated());
                results.AddRange(await CheckScheduledTasksMisconfiguration());
                results.AddRange(await CheckTokenImpersonation());
                results.AddRange(await CheckDLLHijacking());
                results.AddRange(await CheckRegistryAutoRun());
                results.AddRange(await CheckWritableSystemPaths());

                _logger.LogInformation($"Privilege escalation assessment completed. Found {results.Count} techniques");
                return results;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Privilege escalation execution failed");
                results.Add(new PrivilegeEscalationResult
                {
                    TechniqueName = "Privilege Escalation Error",
                    Success = false,
                    Severity = "Error",
                    Description = "Privilege escalation assessment failed",
                    Evidence = ex.Message
                });
                return results;
            }
        }

        private async Task<List<PrivilegeEscalationResult>> CheckUnquotedServicePaths()
        {
            var results = new List<PrivilegeEscalationResult>();

            try
            {
                await Task.Run(() =>
                {
                    using var searcher = new ManagementObjectSearcher("SELECT Name, PathName FROM Win32_Service");
                    using var serviceResults = searcher.Get();

                    foreach (ManagementObject service in serviceResults)
                    {
                        try
                        {
                            var serviceName = service["Name"]?.ToString();
                            var pathName = service["PathName"]?.ToString();

                            if (!string.IsNullOrEmpty(pathName) && IsUnquotedServicePath(pathName))
                            {
                                results.Add(new PrivilegeEscalationResult
                                {
                                    TechniqueName = "Unquoted Service Path",
                                    Success = true,
                                    Severity = "Medium",
                                    Description = $"Service '{serviceName}' has unquoted path with spaces",
                                    Evidence = $"Service: {serviceName}, Path: {pathName}",
                                    TargetPath = pathName,
                                    ServiceName = serviceName
                                });
                            }
                        }
                        catch (Exception ex)
                        {
                            _logger.LogDebug(ex, "Failed to check service path");
                        }
                        finally
                        {
                            service?.Dispose();
                        }
                    }
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to check unquoted service paths");
            }

            return results;
        }

        private async Task<List<PrivilegeEscalationResult>> CheckWeakServicePermissions()
        {
            var results = new List<PrivilegeEscalationResult>();

            try
            {
                await Task.Run(() =>
                {
                    var services = new[] { "Spooler", "BITS", "Schedule", "Themes", "UxSms" };

                    foreach (var serviceName in services)
                    {
                        try
                        {
                            if (CheckServicePermissions(serviceName))
                            {
                                results.Add(new PrivilegeEscalationResult
                                {
                                    TechniqueName = "Weak Service Permissions",
                                    Success = true,
                                    Severity = "High",
                                    Description = $"Service '{serviceName}' may have weak permissions",
                                    Evidence = $"Service: {serviceName} - Potential weak permissions detected",
                                    ServiceName = serviceName
                                });
                            }
                        }
                        catch (Exception ex)
                        {
                            _logger.LogDebug(ex, $"Failed to check permissions for service: {serviceName}");
                        }
                    }
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to check weak service permissions");
            }

            return results;
        }

        private async Task<List<PrivilegeEscalationResult>> CheckAlwaysInstallElevated()
        {
            var results = new List<PrivilegeEscalationResult>();

            try
            {
                await Task.Run(() =>
                {
                    bool hklmEnabled = CheckRegistryValue(Registry.LocalMachine,
                        @"SOFTWARE\Policies\Microsoft\Windows\Installer", "AlwaysInstallElevated", 1);

                    bool hkcuEnabled = CheckRegistryValue(Registry.CurrentUser,
                        @"SOFTWARE\Policies\Microsoft\Windows\Installer", "AlwaysInstallElevated", 1);

                    if (hklmEnabled && hkcuEnabled)
                    {
                        results.Add(new PrivilegeEscalationResult
                        {
                            TechniqueName = "AlwaysInstallElevated",
                            Success = true,
                            Severity = "High",
                            Description = "AlwaysInstallElevated policy is enabled, allowing MSI privilege escalation",
                            Evidence = "HKLM and HKCU AlwaysInstallElevated both set to 1",
                            TargetPath = @"SOFTWARE\Policies\Microsoft\Windows\Installer"
                        });
                    }
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to check AlwaysInstallElevated");
            }

            return results;
        }

        private async Task<List<PrivilegeEscalationResult>> CheckScheduledTasksMisconfiguration()
        {
            var results = new List<PrivilegeEscalationResult>();

            try
            {
                await Task.Run(() =>
                {
                    var taskPaths = new[]
                    {
                        @"C:\Windows\System32\Tasks",
                        @"C:\Windows\Tasks"
                    };

                    foreach (var taskPath in taskPaths)
                    {
                        if (Directory.Exists(taskPath))
                        {
                            try
                            {
                                var files = Directory.GetFiles(taskPath, "*", SearchOption.AllDirectories);
                                foreach (var file in files)
                                {
                                    if (CheckWritePermissions(file))
                                    {
                                        results.Add(new PrivilegeEscalationResult
                                        {
                                            TechniqueName = "Scheduled Task Misconfiguration",
                                            Success = true,
                                            Severity = "Medium",
                                            Description = "Writable scheduled task found",
                                            Evidence = $"Writable task file: {file}",
                                            TargetPath = file
                                        });
                                    }
                                }
                            }
                            catch (Exception ex)
                            {
                                _logger.LogDebug(ex, $"Failed to check tasks in: {taskPath}");
                            }
                        }
                    }
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to check scheduled tasks misconfiguration");
            }

            return results;
        }

        private async Task<List<PrivilegeEscalationResult>> CheckTokenImpersonation()
        {
            var results = new List<PrivilegeEscalationResult>();

            try
            {
                await Task.Run(() =>
                {
                    var requiredPrivileges = new[]
                    {
                        "SeImpersonatePrivilege",
                        "SeAssignPrimaryTokenPrivilege",
                        "SeIncreaseQuotaPrivilege",
                        "SeTcbPrivilege"
                    };

                    foreach (var privilege in requiredPrivileges)
                    {
                        if (_securityContext.HasPrivilege(privilege))
                        {
                            results.Add(new PrivilegeEscalationResult
                            {
                                TechniqueName = "Token Impersonation",
                                Success = true,
                                Severity = "High",
                                Description = $"Process has {privilege} - token impersonation possible",
                                Evidence = $"Current privileges include: {privilege}",
                                PrivilegeName = privilege
                            });
                        }
                    }
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to check token impersonation privileges");
            }

            return results;
        }

        private async Task<List<PrivilegeEscalationResult>> CheckDLLHijacking()
        {
            var results = new List<PrivilegeEscalationResult>();

            try
            {
                await Task.Run(() =>
                {
                    var systemPaths = new[]
                    {
                        Environment.SystemDirectory,
                        Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.Windows), "System"),
                        Environment.GetFolderPath(Environment.SpecialFolder.Windows),
                        Environment.CurrentDirectory
                    };

                    foreach (var path in systemPaths)
                    {
                        if (Directory.Exists(path) && CheckWritePermissions(path))
                        {
                            results.Add(new PrivilegeEscalationResult
                            {
                                TechniqueName = "DLL Hijacking",
                                Success = true,
                                Severity = "High",
                                Description = "Writable system directory found - DLL hijacking possible",
                                Evidence = $"Writable system path: {path}",
                                TargetPath = path
                            });
                        }
                    }
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to check DLL hijacking opportunities");
            }

            return results;
        }

        private async Task<List<PrivilegeEscalationResult>> CheckRegistryAutoRun()
        {
            var results = new List<PrivilegeEscalationResult>();

            try
            {
                await Task.Run(() =>
                {
                    var autorunKeys = new[]
                    {
                        @"SOFTWARE\Microsoft\Windows\CurrentVersion\Run",
                        @"SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce",
                        @"SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Run",
                        @"SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\RunOnce"
                    };

                    foreach (var keyPath in autorunKeys)
                    {
                        try
                        {
                            using var key = Registry.LocalMachine.OpenSubKey(keyPath, true);
                            if (key != null)
                            {
                                results.Add(new PrivilegeEscalationResult
                                {
                                    TechniqueName = "Registry AutoRun",
                                    Success = true,
                                    Severity = "Medium",
                                    Description = "Writable registry autorun key found",
                                    Evidence = $"Writable registry key: HKLM\\{keyPath}",
                                    TargetPath = keyPath
                                });
                            }
                        }
                        catch (Exception ex)
                        {
                            _logger.LogDebug(ex, $"Failed to check registry key: {keyPath}");
                        }
                    }
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to check registry autorun keys");
            }

            return results;
        }

        private async Task<List<PrivilegeEscalationResult>> CheckWritableSystemPaths()
        {
            var results = new List<PrivilegeEscalationResult>();

            try
            {
                await Task.Run(() =>
                {
                    var pathEnvironment = Environment.GetEnvironmentVariable("PATH") ?? string.Empty;
                    var paths = pathEnvironment.Split(';', StringSplitOptions.RemoveEmptyEntries);

                    foreach (var path in paths)
                    {
                        try
                        {
                            if (Directory.Exists(path) && CheckWritePermissions(path))
                            {
                                results.Add(new PrivilegeEscalationResult
                                {
                                    TechniqueName = "Writable System Path",
                                    Success = true,
                                    Severity = "Medium",
                                    Description = "Writable directory in system PATH found",
                                    Evidence = $"Writable PATH directory: {path}",
                                    TargetPath = path
                                });
                            }
                        }
                        catch (Exception ex)
                        {
                            _logger.LogDebug(ex, $"Failed to check PATH directory: {path}");
                        }
                    }
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to check writable system paths");
            }

            return results;
        }

        private bool IsUnquotedServicePath(string pathName)
        {
            if (string.IsNullOrEmpty(pathName)) return false;

            var trimmedPath = pathName.Trim();
            if (trimmedPath.StartsWith("\"") && trimmedPath.Contains("\" ")) return false;

            return trimmedPath.Contains(" ") && !trimmedPath.StartsWith("C:\\Windows\\System32");
        }

        private bool CheckServicePermissions(string serviceName)
        {
            try
            {
                var startInfo = new ProcessStartInfo
                {
                    FileName = "sc.exe",
                    Arguments = $"sdshow {serviceName}",
                    UseShellExecute = false,
                    RedirectStandardOutput = true,
                    CreateNoWindow = true
                };

                using var process = Process.Start(startInfo);
                if (process != null)
                {
                    var output = process.StandardOutput.ReadToEnd();
                    process.WaitForExit();

                    return output.Contains("RP") || output.Contains("WP") || output.Contains("CC");
                }
            }
            catch (Exception ex)
            {
                _logger.LogDebug(ex, $"Failed to check service permissions for: {serviceName}");
            }

            return false;
        }

        private bool CheckRegistryValue(RegistryKey hive, string keyPath, string valueName, object expectedValue)
        {
            try
            {
                using var key = hive.OpenSubKey(keyPath);
                if (key != null)
                {
                    var value = key.GetValue(valueName);
                    return value != null && value.Equals(expectedValue);
                }
            }
            catch (Exception ex)
            {
                _logger.LogDebug(ex, $"Failed to check registry value: {keyPath}\\{valueName}");
            }

            return false;
        }

        private bool CheckWritePermissions(string path)
        {
            try
            {
                if (File.Exists(path))
                {
                    var testFile = Path.Combine(Path.GetDirectoryName(path) ?? string.Empty, $"test_{Guid.NewGuid():N}.tmp");
                    File.WriteAllText(testFile, "test");
                    File.Delete(testFile);
                    return true;
                }
                else if (Directory.Exists(path))
                {
                    var testFile = Path.Combine(path, $"test_{Guid.NewGuid():N}.tmp");
                    File.WriteAllText(testFile, "test");
                    File.Delete(testFile);
                    return true;
                }
            }
            catch
            {
                return false;
            }

            return false;
        }
    }
}