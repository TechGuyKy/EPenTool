using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using System.Diagnostics;
using System.IO;
using Microsoft.Win32;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using EPenT.Core;
using EPenT.Models.Results;
using EPenT.Core;

namespace EPenT.Modules.Exploitation
{
    public class UACBypass
    {
        private readonly IConfiguration _configuration;
        private readonly ILogger<UACBypass> _logger;
        private readonly SecurityContext _securityContext;

        public UACBypass(IConfiguration configuration, ILogger<UACBypass> logger, SecurityContext securityContext)
        {
            _configuration = configuration ?? throw new ArgumentNullException(nameof(configuration));
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
            _securityContext = securityContext ?? throw new ArgumentNullException(nameof(securityContext));
        }

        public async Task<List<UACBypassResult>> ExecuteAsync()
        {
            var results = new List<UACBypassResult>();

            try
            {
                _logger.LogInformation("Starting UAC bypass assessment");

                if (_securityContext.IsElevated)
                {
                    _logger.LogInformation("Already running with elevated privileges - UAC bypass not needed");
                    results.Add(new UACBypassResult
                    {
                        BypassMethod = "Already Elevated",
                        Success = true,
                        Severity = "Info",
                        Description = "Process is already running with elevated privileges",
                        Evidence = "Current process has administrative privileges"
                    });
                    return results;
                }

                results.AddRange(await CheckFodhelperBypass());
                results.AddRange(await CheckEventViewerBypass());
                results.AddRange(await CheckComputerDefaultsBypass());
                results.AddRange(await CheckSDCLTBypass());
                results.AddRange(await CheckSilentCleanupBypass());
                results.AddRange(await CheckMSSettingsBypass());
                results.AddRange(await CheckCMSTPBypass());
                results.AddRange(await CheckDiskCleanupBypass());

                _logger.LogInformation($"UAC bypass assessment completed. Found {results.Count} potential bypasses");
                return results;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "UAC bypass execution failed");
                results.Add(new UACBypassResult
                {
                    BypassMethod = "UAC Bypass Error",
                    Success = false,
                    Severity = "Error",
                    Description = "UAC bypass assessment failed",
                    Evidence = ex.Message
                });
                return results;
            }
        }

        private async Task<List<UACBypassResult>> CheckFodhelperBypass()
        {
            var results = new List<UACBypassResult>();

            try
            {
                await Task.Run(() =>
                {
                    var fodhelperPath = Path.Combine(Environment.SystemDirectory, "fodhelper.exe");

                    if (File.Exists(fodhelperPath))
                    {
                        var registryPath = @"SOFTWARE\Classes\ms-settings\Shell\Open\command";

                        try
                        {
                            using var key = Registry.CurrentUser.CreateSubKey(registryPath);
                            if (key != null)
                            {
                                results.Add(new UACBypassResult
                                {
                                    BypassMethod = "Fodhelper UAC Bypass",
                                    Success = true,
                                    Severity = "High",
                                    Description = "Fodhelper.exe UAC bypass is possible via registry manipulation",
                                    Evidence = $"Registry path writable: HKCU\\{registryPath}",
                                    TargetExecutable = fodhelperPath,
                                    RegistryPath = registryPath,
                                    OSVersions = new[] { "Windows 10", "Windows 11" }
                                });
                            }
                        }
                        catch (Exception ex)
                        {
                            _logger.LogDebug(ex, "Failed to test fodhelper bypass");
                        }
                    }
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to check fodhelper bypass");
            }

            return results;
        }

        private async Task<List<UACBypassResult>> CheckEventViewerBypass()
        {
            var results = new List<UACBypassResult>();

            try
            {
                await Task.Run(() =>
                {
                    var eventvwrPath = Path.Combine(Environment.SystemDirectory, "eventvwr.exe");

                    if (File.Exists(eventvwrPath))
                    {
                        var registryPath = @"SOFTWARE\Classes\mscfile\shell\open\command";

                        try
                        {
                            using var key = Registry.CurrentUser.CreateSubKey(registryPath);
                            if (key != null)
                            {
                                results.Add(new UACBypassResult
                                {
                                    BypassMethod = "Event Viewer UAC Bypass",
                                    Success = true,
                                    Severity = "High",
                                    Description = "Event Viewer UAC bypass is possible via registry hijacking",
                                    Evidence = $"Registry path writable: HKCU\\{registryPath}",
                                    TargetExecutable = eventvwrPath,
                                    RegistryPath = registryPath,
                                    OSVersions = new[] { "Windows 7", "Windows 8", "Windows 10" }
                                });
                            }
                        }
                        catch (Exception ex)
                        {
                            _logger.LogDebug(ex, "Failed to test event viewer bypass");
                        }
                    }
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to check event viewer bypass");
            }

            return results;
        }

        private async Task<List<UACBypassResult>> CheckComputerDefaultsBypass()
        {
            var results = new List<UACBypassResult>();

            try
            {
                await Task.Run(() =>
                {
                    var computerdefaultsPath = Path.Combine(Environment.SystemDirectory, "computerdefaults.exe");

                    if (File.Exists(computerdefaultsPath))
                    {
                        var registryPath = @"SOFTWARE\Classes\ms-settings\Shell\Open\command";

                        try
                        {
                            using var key = Registry.CurrentUser.CreateSubKey(registryPath);
                            if (key != null)
                            {
                                results.Add(new UACBypassResult
                                {
                                    BypassMethod = "ComputerDefaults UAC Bypass",
                                    Success = true,
                                    Severity = "High",
                                    Description = "ComputerDefaults.exe UAC bypass is possible",
                                    Evidence = $"Registry path writable: HKCU\\{registryPath}",
                                    TargetExecutable = computerdefaultsPath,
                                    RegistryPath = registryPath,
                                    OSVersions = new[] { "Windows 10" }
                                });
                            }
                        }
                        catch (Exception ex)
                        {
                            _logger.LogDebug(ex, "Failed to test computerdefaults bypass");
                        }
                    }
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to check computerdefaults bypass");
            }

            return results;
        }

        private async Task<List<UACBypassResult>> CheckSDCLTBypass()
        {
            var results = new List<UACBypassResult>();

            try
            {
                await Task.Run(() =>
                {
                    var sdcltPath = Path.Combine(Environment.SystemDirectory, "sdclt.exe");

                    if (File.Exists(sdcltPath))
                    {
                        var registryPath = @"SOFTWARE\Classes\exefile\shell\runas\command\isolatedCommand";

                        try
                        {
                            using var key = Registry.CurrentUser.CreateSubKey(@"SOFTWARE\Classes\exefile\shell\runas\command");
                            if (key != null)
                            {
                                results.Add(new UACBypassResult
                                {
                                    BypassMethod = "SDCLT UAC Bypass",
                                    Success = true,
                                    Severity = "High",
                                    Description = "SDCLT.exe UAC bypass is possible via registry manipulation",
                                    Evidence = $"Registry path writable: HKCU\\{registryPath}",
                                    TargetExecutable = sdcltPath,
                                    RegistryPath = registryPath,
                                    OSVersions = new[] { "Windows 10", "Windows 11" }
                                });
                            }
                        }
                        catch (Exception ex)
                        {
                            _logger.LogDebug(ex, "Failed to test SDCLT bypass");
                        }
                    }
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to check SDCLT bypass");
            }

            return results;
        }

        private async Task<List<UACBypassResult>> CheckSilentCleanupBypass()
        {
            var results = new List<UACBypassResult>();

            try
            {
                await Task.Run(() =>
                {
                    var silentCleanupPath = @"SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\VolumeCaches\Temporary Files";

                    try
                    {
                        using var key = Registry.LocalMachine.OpenSubKey(silentCleanupPath);
                        if (key != null)
                        {
                            var cleanupString = key.GetValue("CleanupString")?.ToString();
                            if (!string.IsNullOrEmpty(cleanupString))
                            {
                                results.Add(new UACBypassResult
                                {
                                    BypassMethod = "SilentCleanup UAC Bypass",
                                    Success = true,
                                    Severity = "Medium",
                                    Description = "SilentCleanup scheduled task UAC bypass is possible",
                                    Evidence = $"CleanupString: {cleanupString}",
                                    TargetExecutable = "schtasks.exe",
                                    RegistryPath = silentCleanupPath,
                                    OSVersions = new[] { "Windows 10", "Windows 11" }
                                });
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        _logger.LogDebug(ex, "Failed to test SilentCleanup bypass");
                    }
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to check SilentCleanup bypass");
            }

            return results;
        }

        private async Task<List<UACBypassResult>> CheckMSSettingsBypass()
        {
            var results = new List<UACBypassResult>();

            try
            {
                await Task.Run(() =>
                {
                    var registryPath = @"SOFTWARE\Classes\ms-settings\Shell\Open\command";

                    try
                    {
                        using var key = Registry.CurrentUser.CreateSubKey(registryPath);
                        if (key != null)
                        {
                            results.Add(new UACBypassResult
                            {
                                BypassMethod = "MS-Settings UAC Bypass",
                                Success = true,
                                Severity = "High",
                                Description = "MS-Settings protocol handler UAC bypass is possible",
                                Evidence = $"Registry path writable: HKCU\\{registryPath}",
                                TargetExecutable = "ms-settings:",
                                RegistryPath = registryPath,
                                OSVersions = new[] { "Windows 10", "Windows 11" }
                            });
                        }
                    }
                    catch (Exception ex)
                    {
                        _logger.LogDebug(ex, "Failed to test MS-Settings bypass");
                    }
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to check MS-Settings bypass");
            }

            return results;
        }

        private async Task<List<UACBypassResult>> CheckCMSTPBypass()
        {
            var results = new List<UACBypassResult>();

            try
            {
                await Task.Run(() =>
                {
                    var cmstpPath = Path.Combine(Environment.SystemDirectory, "cmstp.exe");

                    if (File.Exists(cmstpPath))
                    {
                        results.Add(new UACBypassResult
                        {
                            BypassMethod = "CMSTP UAC Bypass",
                            Success = true,
                            Severity = "High",
                            Description = "CMSTP.exe UAC bypass is possible via INF file execution",
                            Evidence = $"CMSTP executable available: {cmstpPath}",
                            TargetExecutable = cmstpPath,
                            OSVersions = new[] { "Windows 7", "Windows 8", "Windows 10", "Windows 11" }
                        });
                    }
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to check CMSTP bypass");
            }

            return results;
        }

        private async Task<List<UACBypassResult>> CheckDiskCleanupBypass()
        {
            var results = new List<UACBypassResult>();

            try
            {
                await Task.Run(() =>
                {
                    var cleanmgrPath = Path.Combine(Environment.SystemDirectory, "cleanmgr.exe");

                    if (File.Exists(cleanmgrPath))
                    {
                        var registryPath = @"SOFTWARE\Classes\Directory\shell\CleanOnMe\command";

                        try
                        {
                            using var key = Registry.CurrentUser.CreateSubKey(registryPath);
                            if (key != null)
                            {
                                results.Add(new UACBypassResult
                                {
                                    BypassMethod = "Disk Cleanup UAC Bypass",
                                    Success = true,
                                    Severity = "Medium",
                                    Description = "Disk Cleanup UAC bypass is possible via registry manipulation",
                                    Evidence = $"Registry path writable: HKCU\\{registryPath}",
                                    TargetExecutable = cleanmgrPath,
                                    RegistryPath = registryPath,
                                    OSVersions = new[] { "Windows 7", "Windows 8", "Windows 10" }
                                });
                            }
                        }
                        catch (Exception ex)
                        {
                            _logger.LogDebug(ex, "Failed to test disk cleanup bypass");
                        }
                    }
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to check disk cleanup bypass");
            }

            return results;
        }
    }
}