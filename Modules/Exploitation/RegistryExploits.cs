using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Microsoft.Win32;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using EPenT.Core;
using EPenT.Models.Results;
using EPenT.Core;

namespace EPenT.Modules.Exploitation
{
    public class RegistryExploits
    {
        private readonly IConfiguration _configuration;
        private readonly ILogger<RegistryExploits> _logger;
        private readonly SecurityContext _securityContext;

        public RegistryExploits(IConfiguration configuration, ILogger<RegistryExploits> logger, SecurityContext securityContext)
        {
            _configuration = configuration ?? throw new ArgumentNullException(nameof(configuration));
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
            _securityContext = securityContext ?? throw new ArgumentNullException(nameof(securityContext));
        }

        public async Task<List<RegistryExploitResult>> ExecuteAsync()
        {
            var results = new List<RegistryExploitResult>();

            try
            {
                _logger.LogInformation("Starting registry exploitation assessment");

                results.AddRange(await ExploitAutoRunEntries());
                results.AddRange(await ExploitServiceRegistry());
                results.AddRange(await ExploitEnvironmentVariables());
                results.AddRange(await ExploitSecurityPolicySettings());
                results.AddRange(await ExploitUserAccessControlSettings());
                results.AddRange(await ExploitSystemPolicySettings());
                results.AddRange(await CheckWritableRegistryKeys());

                _logger.LogInformation($"Registry exploitation assessment completed. Found {results.Count} potential exploits");
                return results;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Registry exploitation execution failed");
                results.Add(new RegistryExploitResult
                {
                    ExploitName = "Registry Exploitation Error",
                    Success = false,
                    Severity = "Error",
                    Description = "Registry exploitation assessment failed",
                    Evidence = ex.Message
                });
                return results;
            }
        }

        private async Task<List<RegistryExploitResult>> ExploitAutoRunEntries()
        {
            var results = new List<RegistryExploitResult>();

            try
            {
                await Task.Run(() =>
                {
                    var autorunKeys = new Dictionary<RegistryKey, string>
                    {
                        { Registry.LocalMachine, @"SOFTWARE\Microsoft\Windows\CurrentVersion\Run" },
                        { Registry.LocalMachine, @"SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce" },
                        { Registry.LocalMachine, @"SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Run" },
                        { Registry.LocalMachine, @"SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\RunOnce" },
                        { Registry.CurrentUser, @"SOFTWARE\Microsoft\Windows\CurrentVersion\Run" },
                        { Registry.CurrentUser, @"SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce" }
                    };

                    foreach (var autorunKey in autorunKeys)
                    {
                        try
                        {
                            using var key = autorunKey.Key.OpenSubKey(autorunKey.Value, true);
                            if (key != null)
                            {
                                results.Add(new RegistryExploitResult
                                {
                                    ExploitName = "AutoRun Registry Modification",
                                    Success = true,
                                    Severity = "High",
                                    Description = $"Registry autorun key is writable: {autorunKey.Value}",
                                    Evidence = $"Writable registry key: {autorunKey.Key.Name}\\{autorunKey.Value}",
                                    RegistryPath = $"{autorunKey.Key.Name}\\{autorunKey.Value}",
                                    RegistryHive = autorunKey.Key.Name
                                });

                                foreach (var valueName in key.GetValueNames())
                                {
                                    var value = key.GetValue(valueName)?.ToString();
                                    if (!string.IsNullOrEmpty(value))
                                    {
                                        results.Add(new RegistryExploitResult
                                        {
                                            ExploitName = "AutoRun Entry Modification",
                                            Success = true,
                                            Severity = "Medium",
                                            Description = $"Existing autorun entry can be modified: {valueName}",
                                            Evidence = $"Entry: {valueName} = {value}",
                                            RegistryPath = $"{autorunKey.Key.Name}\\{autorunKey.Value}\\{valueName}",
                                            RegistryHive = autorunKey.Key.Name,
                                            RegistryValue = valueName
                                        });
                                    }
                                }
                            }
                        }
                        catch (UnauthorizedAccessException)
                        {
                            // Expected for protected keys
                        }
                        catch (Exception ex)
                        {
                            _logger.LogDebug(ex, $"Failed to check autorun key: {autorunKey.Value}");
                        }
                    }
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to exploit autorun entries");
            }

            return results;
        }

        private async Task<List<RegistryExploitResult>> ExploitServiceRegistry()
        {
            var results = new List<RegistryExploitResult>();

            try
            {
                await Task.Run(() =>
                {
                    using var servicesKey = Registry.LocalMachine.OpenSubKey(@"SYSTEM\CurrentControlSet\Services");
                    if (servicesKey != null)
                    {
                        foreach (var serviceName in servicesKey.GetSubKeyNames())
                        {
                            try
                            {
                                using var serviceKey = servicesKey.OpenSubKey(serviceName, true);
                                if (serviceKey != null)
                                {
                                    var imagePath = serviceKey.GetValue("ImagePath")?.ToString();
                                    var objectName = serviceKey.GetValue("ObjectName")?.ToString();
                                    var start = serviceKey.GetValue("Start")?.ToString();

                                    results.Add(new RegistryExploitResult
                                    {
                                        ExploitName = "Service Registry Modification",
                                        Success = true,
                                        Severity = "Critical",
                                        Description = $"Service registry key is writable: {serviceName}",
                                        Evidence = $"Service: {serviceName}, ImagePath: {imagePath}, Account: {objectName}",
                                        RegistryPath = $@"HKLM\SYSTEM\CurrentControlSet\Services\{serviceName}",
                                        RegistryHive = "HKEY_LOCAL_MACHINE",
                                        ServiceName = serviceName
                                    });
                                }
                            }
                            catch (UnauthorizedAccessException)
                            {
                                // Expected for most protected service keys
                            }
                            catch (Exception ex)
                            {
                                _logger.LogDebug(ex, $"Failed to check service registry: {serviceName}");
                            }
                        }
                    }
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to exploit service registry");
            }

            return results;
        }

        private async Task<List<RegistryExploitResult>> ExploitEnvironmentVariables()
        {
            var results = new List<RegistryExploitResult>();

            try
            {
                await Task.Run(() =>
                {
                    var envKeys = new Dictionary<RegistryKey, string>
                    {
                        { Registry.LocalMachine, @"SYSTEM\CurrentControlSet\Control\Session Manager\Environment" },
                        { Registry.CurrentUser, @"Environment" }
                    };

                    foreach (var envKey in envKeys)
                    {
                        try
                        {
                            using var key = envKey.Key.OpenSubKey(envKey.Value, true);
                            if (key != null)
                            {
                                var pathValue = key.GetValue("PATH")?.ToString();

                                results.Add(new RegistryExploitResult
                                {
                                    ExploitName = "Environment Variable Modification",
                                    Success = true,
                                    Severity = "High",
                                    Description = "Environment variables registry key is writable",
                                    Evidence = $"PATH variable: {pathValue}",
                                    RegistryPath = $"{envKey.Key.Name}\\{envKey.Value}",
                                    RegistryHive = envKey.Key.Name,
                                    RegistryValue = "PATH"
                                });

                                foreach (var valueName in key.GetValueNames())
                                {
                                    if (string.Equals(valueName, "PATH", StringComparison.OrdinalIgnoreCase) ||
                                        string.Equals(valueName, "PATHEXT", StringComparison.OrdinalIgnoreCase))
                                    {
                                        results.Add(new RegistryExploitResult
                                        {
                                            ExploitName = "Critical Environment Variable",
                                            Success = true,
                                            Severity = "Critical",
                                            Description = $"Critical environment variable '{valueName}' is modifiable",
                                            Evidence = $"Variable: {valueName} = {key.GetValue(valueName)}",
                                            RegistryPath = $"{envKey.Key.Name}\\{envKey.Value}\\{valueName}",
                                            RegistryHive = envKey.Key.Name,
                                            RegistryValue = valueName
                                        });
                                    }
                                }
                            }
                        }
                        catch (UnauthorizedAccessException)
                        {
                            // Expected for protected environment keys
                        }
                        catch (Exception ex)
                        {
                            _logger.LogDebug(ex, $"Failed to check environment key: {envKey.Value}");
                        }
                    }
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to exploit environment variables");
            }

            return results;
        }

        private async Task<List<RegistryExploitResult>> ExploitSecurityPolicySettings()
        {
            var results = new List<RegistryExploitResult>();

            try
            {
                await Task.Run(() =>
                {
                    var securityKeys = new[]
                    {
                        @"SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System",
                        @"SOFTWARE\Policies\Microsoft\Windows\Safer\CodeIdentifiers",
                        @"SYSTEM\CurrentControlSet\Control\Lsa"
                    };

                    foreach (var keyPath in securityKeys)
                    {
                        try
                        {
                            using var key = Registry.LocalMachine.OpenSubKey(keyPath, true);
                            if (key != null)
                            {
                                results.Add(new RegistryExploitResult
                                {
                                    ExploitName = "Security Policy Modification",
                                    Success = true,
                                    Severity = "Critical",
                                    Description = $"Security policy registry key is writable: {keyPath}",
                                    Evidence = $"Writable security key: HKLM\\{keyPath}",
                                    RegistryPath = $"HKLM\\{keyPath}",
                                    RegistryHive = "HKEY_LOCAL_MACHINE"
                                });

                                CheckSpecificSecurityValues(key, keyPath, results);
                            }
                        }
                        catch (UnauthorizedAccessException)
                        {
                            // Expected for most security policy keys
                        }
                        catch (Exception ex)
                        {
                            _logger.LogDebug(ex, $"Failed to check security key: {keyPath}");
                        }
                    }
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to exploit security policy settings");
            }

            return results;
        }

        private async Task<List<RegistryExploitResult>> ExploitUserAccessControlSettings()
        {
            var results = new List<RegistryExploitResult>();

            try
            {
                await Task.Run(() =>
                {
                    var uacKeyPath = @"SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System";

                    try
                    {
                        using var uacKey = Registry.LocalMachine.OpenSubKey(uacKeyPath, true);
                        if (uacKey != null)
                        {
                            var enableLUA = uacKey.GetValue("EnableLUA");
                            var consentPromptBehaviorAdmin = uacKey.GetValue("ConsentPromptBehaviorAdmin");
                            var promptOnSecureDesktop = uacKey.GetValue("PromptOnSecureDesktop");

                            results.Add(new RegistryExploitResult
                            {
                                ExploitName = "UAC Settings Modification",
                                Success = true,
                                Severity = "Critical",
                                Description = "UAC registry settings are writable",
                                Evidence = $"EnableLUA: {enableLUA}, ConsentPromptBehaviorAdmin: {consentPromptBehaviorAdmin}",
                                RegistryPath = $"HKLM\\{uacKeyPath}",
                                RegistryHive = "HKEY_LOCAL_MACHINE"
                            });

                            if (enableLUA != null && enableLUA.ToString() == "0")
                            {
                                results.Add(new RegistryExploitResult
                                {
                                    ExploitName = "UAC Disabled",
                                    Success = true,
                                    Severity = "High",
                                    Description = "UAC is currently disabled",
                                    Evidence = "EnableLUA = 0",
                                    RegistryPath = $"HKLM\\{uacKeyPath}\\EnableLUA",
                                    RegistryHive = "HKEY_LOCAL_MACHINE",
                                    RegistryValue = "EnableLUA"
                                });
                            }
                        }
                    }
                    catch (UnauthorizedAccessException)
                    {
                        // Expected for UAC policy keys
                    }
                    catch (Exception ex)
                    {
                        _logger.LogDebug(ex, "Failed to check UAC settings");
                    }
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to exploit UAC settings");
            }

            return results;
        }

        private async Task<List<RegistryExploitResult>> ExploitSystemPolicySettings()
        {
            var results = new List<RegistryExploitResult>();

            try
            {
                await Task.Run(() =>
                {
                    var policyKeys = new[]
                    {
                        @"SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate",
                        @"SOFTWARE\Policies\Microsoft\Windows\Installer",
                        @"SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\Explorer",
                        @"SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System"
                    };

                    foreach (var keyPath in policyKeys)
                    {
                        try
                        {
                            using var key = Registry.LocalMachine.OpenSubKey(keyPath, true);
                            if (key != null)
                            {
                                results.Add(new RegistryExploitResult
                                {
                                    ExploitName = "System Policy Modification",
                                    Success = true,
                                    Severity = "High",
                                    Description = $"System policy registry key is writable: {keyPath}",
                                    Evidence = $"Writable policy key: HKLM\\{keyPath}",
                                    RegistryPath = $"HKLM\\{keyPath}",
                                    RegistryHive = "HKEY_LOCAL_MACHINE"
                                });

                                CheckAlwaysInstallElevated(key, keyPath, results);
                            }
                        }
                        catch (UnauthorizedAccessException)
                        {
                            // Expected for most policy keys
                        }
                        catch (Exception ex)
                        {
                            _logger.LogDebug(ex, $"Failed to check policy key: {keyPath}");
                        }
                    }
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to exploit system policy settings");
            }

            return results;
        }

        private async Task<List<RegistryExploitResult>> CheckWritableRegistryKeys()
        {
            var results = new List<RegistryExploitResult>();

            try
            {
                await Task.Run(() =>
                {
                    var criticalKeys = new[]
                    {
                        @"SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest",
                        @"SYSTEM\CurrentControlSet\Control\LSA",
                        @"SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon",
                        @"SOFTWARE\Microsoft\Active Setup\Installed Components",
                        @"SOFTWARE\Classes\exefile\shell\open\command"
                    };

                    foreach (var keyPath in criticalKeys)
                    {
                        try
                        {
                            using var key = Registry.LocalMachine.OpenSubKey(keyPath, true);
                            if (key != null)
                            {
                                results.Add(new RegistryExploitResult
                                {
                                    ExploitName = "Critical Registry Key Writable",
                                    Success = true,
                                    Severity = "Critical",
                                    Description = $"Critical registry key is writable: {keyPath}",
                                    Evidence = $"Writable critical key: HKLM\\{keyPath}",
                                    RegistryPath = $"HKLM\\{keyPath}",
                                    RegistryHive = "HKEY_LOCAL_MACHINE"
                                });
                            }
                        }
                        catch (UnauthorizedAccessException)
                        {
                            // Expected for protected keys
                        }
                        catch (Exception ex)
                        {
                            _logger.LogDebug(ex, $"Failed to check critical key: {keyPath}");
                        }
                    }
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to check writable registry keys");
            }

            return results;
        }

        private void CheckSpecificSecurityValues(RegistryKey key, string keyPath, List<RegistryExploitResult> results)
        {
            try
            {
                var securityValues = new Dictionary<string, string>
                {
                    { "EnableLUA", "UAC User Account Control" },
                    { "ConsentPromptBehaviorAdmin", "UAC Admin Consent Prompt" },
                    { "ConsentPromptBehaviorUser", "UAC User Consent Prompt" },
                    { "PromptOnSecureDesktop", "UAC Secure Desktop" },
                    { "FilterAdministratorToken", "UAC Administrator Token Filter" },
                    { "DisableCAD", "Ctrl+Alt+Del Requirement" }
                };

                foreach (var secValue in securityValues)
                {
                    var value = key.GetValue(secValue.Key);
                    if (value != null)
                    {
                        results.Add(new RegistryExploitResult
                        {
                            ExploitName = "Security Setting Modification",
                            Success = true,
                            Severity = "High",
                            Description = $"{secValue.Value} setting is modifiable",
                            Evidence = $"{secValue.Key} = {value}",
                            RegistryPath = $"HKLM\\{keyPath}\\{secValue.Key}",
                            RegistryHive = "HKEY_LOCAL_MACHINE",
                            RegistryValue = secValue.Key
                        });
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogDebug(ex, "Failed to check specific security values");
            }
        }

        private void CheckAlwaysInstallElevated(RegistryKey key, string keyPath, List<RegistryExploitResult> results)
        {
            try
            {
                if (keyPath.Contains("Installer"))
                {
                    var alwaysInstallElevated = key.GetValue("AlwaysInstallElevated");
                    if (alwaysInstallElevated != null)
                    {
                        results.Add(new RegistryExploitResult
                        {
                            ExploitName = "AlwaysInstallElevated Setting",
                            Success = true,
                            Severity = "Critical",
                            Description = "AlwaysInstallElevated policy setting found",
                            Evidence = $"AlwaysInstallElevated = {alwaysInstallElevated}",
                            RegistryPath = $"HKLM\\{keyPath}\\AlwaysInstallElevated",
                            RegistryHive = "HKEY_LOCAL_MACHINE",
                            RegistryValue = "AlwaysInstallElevated"
                        });
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogDebug(ex, "Failed to check AlwaysInstallElevated setting");
            }
        }
    }
}